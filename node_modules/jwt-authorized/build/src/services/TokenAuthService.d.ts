import { EventsInterface } from "../loaders/events";
import { TokenConfig } from "../config/tokenConfigGenerator";
import { TokenUserConstructor, UserInfoInstance } from "../models/TokenUser";
export declare type TokenPayload = {
    aud: string;
    exp: number;
};
export declare type TokenConfigOverride = Partial<TokenConfig>;
export default class TokenAuthService {
    models: {
        TokenUser: TokenUserConstructor;
    };
    tokenConfig: TokenConfig;
    events: EventsInterface;
    constructor({ models, tokenConfig, events }: {
        models: {
            TokenUser: TokenUserConstructor;
        };
        tokenConfig: TokenConfig;
        events: EventsInterface;
    });
    authenticateTokenStrategy({ token }: {
        token: string;
    }): import("../models/TokenUser").TokenUserInstance;
    verifyToken({ token }: {
        token: string;
    }): TokenPayload | false | never;
    /**
     * IMPORTANT: If you are going to verify from a different server than the one who signs,
     * and that server is to be managed by someone else than the signing server,
     * then it makes sense to switch to RSA in order to withhold the signing
     * power within the signing server owners.
     */
    generateToken(user: UserInfoInstance, configOverride?: TokenConfigOverride): string;
}
//# sourceMappingURL=TokenAuthService.d.ts.map