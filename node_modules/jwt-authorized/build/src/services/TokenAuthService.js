"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var canUse_1 = require("../utils/canUse");
var TokenAuthService = /** @class */ (function () {
    function TokenAuthService(_a) {
        var models = _a.models, tokenConfig = _a.tokenConfig, events = _a.events;
        this.models = models;
        this.tokenConfig = tokenConfig;
        this.events = events;
    }
    TokenAuthService.prototype.authenticateTokenStrategy = function (_a) {
        var token = _a.token;
        var TokenUser = this.models.TokenUser;
        if (typeof token !== 'string') {
            throw new Error('TokenAuthService:authenticateTokenStrategy: no string token was provided, ensure that you pass a string token to this method');
        }
        var payload = this.verifyToken({ token: token });
        if (!payload) {
            this.events.emit('TokenAuthService:authenticateTokenStrategy:fail wrong secret', token);
            throw new Error("TokenAuthService:authenticateTokenStrategy() authentication fail, please login again " + token);
        }
        var expirationTime = payload.exp, UUID = payload.aud;
        if (expirationTime <= this.tokenConfig.now()) {
            this.events.emit('TokenAuthService:authenticateTokenStrategy:fail expired token', token);
            throw new Error("TokenAuthService:authenticateTokenStrategy() authentication fail, please login again " + token);
        }
        var tokenUser = new TokenUser({ userInfo: { UUID: UUID }, token: token });
        this.events.emit('TokenAuthService:authenticateTokenStrategy:success', tokenUser);
        return tokenUser;
    };
    TokenAuthService.prototype.verifyToken = function (_a) {
        var token = _a.token;
        if (token === undefined) {
            throw new Error('verifyToken({ token }), token param not provided (undefined)');
        }
        if (typeof token !== 'string' || token.split('.').length !== 3) {
            throw new Error('verifyToken({ token }), token param must be a string with two dots');
        }
        var _b = this.tokenConfig, engine = _b.engine, algorithm = _b.algorithm, keys = _b.keys;
        var secret = null;
        if (canUse_1.canUsePrivateKey(algorithm, keys)) {
            secret = keys.privateKey;
        }
        else if (canUse_1.canUsePublicKey(algorithm, keys)) {
            secret = keys.publicKey;
        }
        else {
            throw new Error("TokenAuthService:verifyToken() unsupported encryption algorithm " + algorithm);
        }
        var tokenMatchesSecret = engine.verify(token, algorithm, secret);
        if (!tokenMatchesSecret) {
            this.events.emit('TokenAuthService:verifyToken:fail', token);
            return false;
        }
        var jsonPayload = engine.decode(token).payload;
        this.events.emit('TokenAuthService:verifyToken:success', jsonPayload);
        if (!jsonPayload) {
            this.events.emit('TokenAuthService:verifyToken:fail', token);
            throw new Error("TokenAuthService:verifyToken() authentication fail provided: " + token);
        }
        var payload = JSON.parse(jsonPayload);
        if (!payload.exp || !payload.aud) {
            this.events.emit('TokenAuthService:verifyToken:fail token was malformed by server', token);
            throw new Error("TokenAuthService:verifyToken() authentication fail " + token);
        }
        return payload;
    };
    /**
     * IMPORTANT: If you are going to verify from a different server than the one who signs,
     * and that server is to be managed by someone else than the signing server,
     * then it makes sense to switch to RSA in order to withhold the signing
     * power within the signing server owners.
     */
    TokenAuthService.prototype.generateToken = function (user, configOverride) {
        var _a;
        if (configOverride === void 0) { configOverride = {}; }
        var finalConfig = __assign(__assign({}, this.tokenConfig), configOverride);
        var engine = finalConfig.engine, expiresIn = finalConfig.expiresIn, algorithm = finalConfig.algorithm, keys = finalConfig.keys;
        if (!canUse_1.canUsePrivateKey(algorithm, keys)) {
            throw new Error("In order to sign and generate tokens with the supported algorithms a \"privateKey\" is required");
        }
        var secret = keys.privateKey;
        var secretOrPrivateKey = algorithm.charAt(0) === 'R'
            ? 'privateKey'
            : 'secret';
        var userID = user && (user.UUID || user.ID || null);
        if (null === userID) {
            throw new Error("TokenAuthService:generateToken() Error: a param with prop { user } must have either a UUID or ID property " + user);
        }
        var payload = {
            aud: userID,
            exp: expiresIn(),
        };
        var options = (_a = {
                header: {
                    alg: algorithm
                },
                payload: payload
            },
            _a[secretOrPrivateKey] = secret,
            _a);
        var token = engine.sign(options);
        this.events.emit('TokenAuthService:generateToken:success', token);
        return token;
    };
    return TokenAuthService;
}());
exports.default = TokenAuthService;
