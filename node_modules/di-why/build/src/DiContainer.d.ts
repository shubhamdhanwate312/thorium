export interface LoggerInterface {
    debug: (...params: any[]) => any;
}
export interface InjectableInterface {
    inject: (...args: any[]) => any;
}
export declare type SubscriberCallbackParams = {
    serviceLocator: DiContainer;
    params: any[];
};
export declare type SubscriptionsDict = {
    [k: string]: (param: SubscriberCallbackParams) => any;
};
export declare type GetInstanceType<C> = C extends new (...args: any[]) => infer T ? T : never;
export declare type GetInjectableSubclass<T> = T extends InjectableInterface ? T : never;
export declare type AfterCallbackProps<T, D = DependenciesDict> = {
    me: T;
    serviceLocator: DiContainer;
    el: LoadDictElement<T>;
    deps: D;
};
export declare type BeforeCallbackProps<T, D = DependenciesDict> = {
    serviceLocator: DiContainer;
    el: LoadDictElement<T>;
    deps: D;
};
export declare type ConstructibleProp<T> = {
    constructible: new (...args: any[]) => T;
};
export declare type InstanceProp<T> = {
    instance: T;
};
export declare type InjectableProp<T> = {
    injectable: GetInjectableSubclass<T>;
};
export declare type FactoryProp<T> = {
    factory: (...args: any[]) => T;
};
declare type LdePropsUnion<T> = {} & ConstructibleProp<T> & InstanceProp<T> & InjectableProp<T> & FactoryProp<T>;
declare type LdeXOR<T, K extends keyof LdePropsUnion<T>> = Pick<LdePropsUnion<T>, K> & Omit<Partial<LdePropsUnion<T>>, K>;
declare type Common<T, D = DependenciesDict, BD = Partial<D>> = {} & {
    deps?: D;
} & {
    destructureDeps?: boolean;
} & {
    locateDeps?: LocatableNestedDependenciesDict;
} & {
    after?: (props: AfterCallbackProps<T, D>) => (T | void | Promise<T | void>);
} & {
    before?: (props: BeforeCallbackProps<T, BD>) => (D | void | Promise<D | void>);
} & {
    subscriptions?: SubscriptionsDict;
};
export declare type LoadDictElement<T = any, D = DependenciesDict, BD = Partial<D>> = {} & (LdeXOR<T, "constructible"> | LdeXOR<T, "instance"> | LdeXOR<T, "injectable"> | LdeXOR<T, "factory">) & Common<T, D, BD>;
export declare type LoadDict = {
    [P: string]: LoadDictElement;
};
export declare type LoadPromisesDict = {
    [k: string]: Promise<any>;
};
export declare type ServiceLocatorDict = {
    [k: string]: any;
};
export declare type DependenciesDict = ServiceLocatorDict;
export declare type LocatableNestedDependenciesDict = {
    [k: string]: string | LocatableNestedSubDependenciesDict;
};
export declare type LocatableNestedSubDependenciesDict = {
    [k: string]: string | LocatableNestedSubDependenciesDict;
} | {
    [i: number]: string | LocatableNestedSubDependenciesDict;
};
declare class DiContainer {
    logger: LoggerInterface;
    locatorRefDict: ServiceLocatorDict;
    loadDict: LoadDict;
    loading: boolean;
    loadPromises: LoadPromisesDict;
    constructor({ logger, load }: {
        logger?: LoggerInterface;
        load?: LoadDict;
    });
    loadAll(injectionDict?: LoadDict): Promise<boolean>;
    addToLoadDict(injectionDict: LoadDict): void;
    addToLoadingPromisesIfNotAlreadyThere(refName: string, promise: Promise<any>): boolean;
    deepLocateDeps(locateDeps: LocatableNestedDependenciesDict): Promise<{
        [x: string]: any;
    }>;
    mergeObjects(a: any, b: any): any;
    load(refName: string): Promise<any>;
    get<T = any>(refName: string): Promise<T>;
    getLoadPromise(refName: string): Promise<any>;
    set(refName: string, val: any): any;
    has(refName: string): boolean;
    isValidRefNameOrThrow(refName: string): void;
    emit(eventName: string, ...params: any[]): Promise<void>;
    static inject({ logger }: {
        logger: LoggerInterface;
    }): void;
    static getLatestContainer(): DiContainer;
    static getFirstContainer(): DiContainer;
    static getNthContainer(n: number): DiContainer;
    static getContainers(): DiContainer[];
}
export default DiContainer;
//# sourceMappingURL=DiContainer.d.ts.map